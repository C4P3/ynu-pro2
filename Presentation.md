# チーム開発成果報告 プレゼンテーション草稿（担当パート）

## はじめに (0.5分)

（スライド：自己紹介、担当範囲）

> 皆さん、こんにちは。〇〇です。
> 
> この「タイピング探検ゲーム」開発プロジェクトでは、主に全体のシステム設計と、これからお話しする「ステージの自動生成」および「マルチプレイ機能」の実装を担当しました。
> 
> 今日は、このゲームのコアな体験を支える2つの技術、「プロシージャル技術を用いたステージ自動生成」と、「Mirrorとリレーサーバーを活用したマルチプレイの実現」について、技術的な挑戦を中心にお話しします。

---

## 1. パーリンノイズによる無限のステージ生成 (4分)

（スライド：自動生成された様々なマップのスクリーンショット、パーリンノイズの白黒画像）

> まず、このゲームの大きな特徴である「プレイするたびに姿を変えるステージ」を実現した技術についてです。
> 
> なぜステージを自動生成にしたかというと、プレイヤーに毎回���鮮な気持ちで探索を楽しんでもらい、リプレイ性を高めるためです。
> 
> この自動生成には、**パーリンノイズ**というアルゴリズムを利用しています。
> 
> （スライドにパーリンノイズの画像を表示しながら）
> 
> パーリンノイズは、このように一見ランダムに見えつつも、自然な連続性を持つノイズを生成できるのが特徴です。ゲームの世界では、地形やテクスチャの生成によく使われます。
> 
> 私たちのゲームでは、このノイズを元にマップのどこが「壁」になり、どこが「道」になるかを決定しています。
> 
> （スライド：パーリンノイズ画像と、それから生成されたゲームマップを並べて表示）
> 
> 具体的には、`LevelManager.cs`というスクリプトで、2次元のパーリンノイズを生成し、その値がある「しきい値」より大きいかどうかで、タイルを配置するかどうかを判断しています。
> 
> ただ、単純にノイズを使うだけでは、道が狭すぎたり、プレイヤーが閉じ込められたりする、面白くないマップができてしまいます。
> 
> そこで、ノイズを���成する際の**スケール（拡大率）**や、先ほどの**しきい値**といったパラメータを何度も調整し、面白さと探索のしやすさを両立したマップが生成されるように試行錯誤を重ねました。
> 
> これにより、プレイヤーは無限に生成されるステージの中から、毎回新しい発見や攻略法を見つけ出す楽しみを味わうことができます。先ほどデモでお見せしたマップも、この技術によって作られています。

---

## 2. MirrorとRelayによるマルチプレイ体験の実現 (9分)

（スライド：マルチプレイの様子のスクリーンショット）

> 次に、このゲームのもう一つの柱であるマルチプレイ機能についてです。
> 
> この実装には、Unity向けのオープンソースなネットワークライブラリである**Mirror**を主に使用しました。Mirrorは、ゲーム内のオブジェクトの状態を、複数のプレイヤー間で同期させるための強力なフレームワークです。
> 
> ここでは、私たちが直面した「どうやってプレイヤーとステージを同期させるか？」そして「どうやって各プレイヤーに独立した視点を提供するか？」という2つの課題と、その解決策について詳しくお話しします。
> 
> ### 課題1：ゲームワールドの同期
> 
> （スライド：ホストとクライアントが同じマップを共有している図）
> 
> マルチプレイでは、当然ですが、全プレイヤーが同じステージで、同じ状態を共有しなければなりません。
> 
> まず**ステージの同期**ですが、先ほどお話ししたパーリンノイズによる自動生成がここでも活きてきます。
> 
> マップの形状を決める「シード値」というものがあるのですが、これをホスト側で決定し、クライアントの接続時に共有します。クライアントは受け取ったシード値を使ってローカルでマップを生成します。
> 
> これにより、巨大なマップデータをネットワークで送信することなく、ごく僅かなデータ量で、全プレイヤーが寸分違わぬステージを再現できるわけです。
> 
> 次に**プレイヤーの同期**です。キャラクターの位置や状態は、Mirrorの `NetworkTransform` コンポーネントや `[SyncVar]` という属性で自動的に同期されます。
> 
> プレイヤーがタイピングで移動する、といったアクションは、まずクライアントからサーバー、つまりホストPCに `[Command]` として送信されます。ホストがそのアクションを処理し、キャラクターの状態を更新すると、その結果が `[SyncVar]` によって全クライアントに伝播します。
> 
> このように、**サーバー（ホスト）が絶対的な権限を持つ**ことで、処理の矛盾を防ぎ、ゲームの状態を正しく同期させています。
> 
> ### 課題2：レイヤーを活用した独立した視点の実現
> 
> （スライド：プレイヤー1の画面とプレイヤー2の画面を並べ、それぞれ自分用のUIやカメラアングルになっている様子を示す）
> 
> さて、同期はできましたが、ここで新たな問題が生まれます。
> 
> Unityのシーン上には、プレイヤー2人分のキャラクターやカメラ、UIがすべて存在しています。そのままでは、プレイヤー1の画面にプレイヤー2のUIが表示されたり、カメラが意図しない相手を追いかけてしまいます。
> 
> そこで私たちは、Unityの**レイヤー機能**を使い、各プレイヤーが見る「ワールド」を擬似的に分離しました。
> 
> （��ライド：レイヤー設定のスクリーンショットと、カメラのCulling Mask設定の図）
> 
> 具体的には、「LocalPlayer」と「RemotePlayer」という2つのレイヤーを用意します。
> 
> Mirrorには、自分の操作するキャラクターかどうかを判定する `isLocalPlayer` という便利なプロパティがあります。
> 
> これを使い、スクリプトで、自分自身のキャラクターは「LocalPlayer」レイヤーに、相手のキャラクターは「RemotePlayer」レイヤーに、それぞれ自動で割り振るようにしました。
> 
> そして、メインカメラの設定で、「LocalPlayer」レイヤーは描画しないように設定します。こうすることで、例えば自分のキャラクターの頭の中が見えてしまう、といった三人称視点ゲーム特有の問題を防ぎつつ、相手のキャラクターはちゃんと表示することができます。
> 
> UIも同様に、`isLocalPlayer` をチェックして、自分用のUIのみを表示するように制御しています。
> 
> このようにレイヤーを上手��使うことで、1つのシーンの中に、それぞれのプレイヤーにとって独立した、快適な視点を作り出すことができました。
> 
> ### 課題3：P2P通信の課題とリレーサーバーによる解決
> 
> （スライド：P2P通信とリレーサーバーの比較図）
> 
> 最後に、通信経路の問題です。
> 
> ここまでの仕組みは、P2P、つまりプレイヤー同士が直接通信することが前提ですが、これには2つの大きな課題があります。
> 
> 1つは、**NAT越えの問題**。家庭のルーターなどが原因で、プレイヤー同士が繋がらないケースが発生します。
> 
> もう1つは、**IPアドレスの匿名性**。P2Pではお互いのIPアドレスが分かってしまい、セキュリティ上好ましくありません。
> 
> （スライド：リレーサーバーの仕組みを図で示す）
> 
> この課題を解決するために、私たちは**Unity Relay**というリレーサーバーを利用しました。
> 
> リレーサーバーは、通信を「中継」してくれるサーバーです。全てのプレイヤーはこのサーバーを介して通信することで、NATやIPアドレスの問題をまとめて解���できます。
> 
> これにより、プレイヤーは自分の情報を明かすことなく、安全かつ安定してマルチプレイを楽しめるわけです。
> 
> この仕組みは `MyRelayNetworkManager.cs` に実装されており、PlayFabでのマッチメイキング成功後に、Relayサーバーへ接続しています。

---

## まとめ (0.5分)

> 以上のように、このプロジェクトでは、パーリンノイズによる「無限の楽しさ」、そしてMirrorとRelay、さらにレイヤーの活用といった技術的工夫によって「安全で快適なマルチプレイ」を実現しました。
> 
> これらの技術的挑戦を通じて、プレイヤーにユニークな体験を提供できたと考えています。
> 
> ご清聴ありがとうございました。

---
### 質疑応答で聞かれるかもしれないこと

- **Q. パーリンノイズのシード値はどうしていますか？**
    - A. マルチプレイでは、両プレイヤーが同じステージを生成する必要があるため、ホスト側で生成したシード値を、接続してきたクライアントに共有する仕組みを入れています。
- **Q. アイテムの同期はどうなっていますか？**
    - A. アイテムの取得��効果の発動はサーバー（ホスト）側で権限を持って処理し、その結果（例：スコアの変動、相手へのエフェクト）を `[ClientRpc]` で全プレイヤーに通知しています。（※`GEMINI.md`のTODOにある通り、ここはまだ課題がある点も正直に話すと良い）
- **Q. なぜUnity公式のNetcode for GameObjectsではなくMirrorを選んだのですか？**
    - A. 開発開始時点での知見や、参考資料の多さからMirrorを選択しました。基本的な考え方は似ていますが、Mirrorは長年の実績があるライブラリです。
- **Q. ネットワーク越しにオブジェクトを生成・破棄する際はどうしていますか？**
    - A. Mirrorが提供する `NetworkServer.Spawn()` と `NetworkServer.Destroy()` を利用しています。これにより、例えば爆弾アイテムの使用などを、サーバー（ホスト）の権限で安全に全プレイヤーの環境で同期させることができます。
